package generator

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/ha1tch/reminty/internal/parser"
)

// Generator produces Go code from JSX AST
type Generator struct {
	indent         int
	output         strings.Builder
	suggestions    []string
	warnings       []string
	usesFragment   bool
	usesEach       bool
	usesIf         bool
	usesIfElse     bool
	inMapBody      bool
	inIfElseReturn bool  // true when generating content that will be returned from IfElse
	currentItemVar string
	currentParams  map[string]bool   // tracks current function's parameter names
	objectParams   map[string]bool   // tracks which params are object/map types
}

// NewGenerator creates a new code generator
func NewGenerator() *Generator {
	return &Generator{
		indent: 0,
	}
}

// Generate produces Go code from a parse result
func (g *Generator) Generate(result *parser.ParseResult) string {
	g.output.Reset()

	// Write package declaration
	g.writeln("package main")
	g.writeln("")
	
	// Add warning
	g.writeln("// Generated by reminty - review TODOs before use")
	g.writeln("")

	// Write imports
	g.writeln("import (")
	g.writeln("\t\"fmt\"")
	g.writeln("")
	g.writeln("\tmi \"github.com/ha1tch/minty\"")
	g.writeln(")")
	g.writeln("")
	g.writeln("var _ = fmt.Sprint // silence unused import")
	g.writeln("")

	// Generate components
	for _, comp := range result.File.Components {
		g.generateComponent(&comp)
		g.writeln("")
	}

	// Add suggestions as comments at the end
	if len(result.Suggestions) > 0 {
		g.writeln("// =============================================================================")
		g.writeln("// TRANSLATION NOTES")
		g.writeln("// =============================================================================")
		for _, s := range result.Suggestions {
			g.writef("// Line %d: %s\n", s.Line, s.ReactCode)
			g.writef("//   → %s\n", s.MintyHint)
			g.writeln("//")
		}
	}

	return g.output.String()
}

// GenerateNode generates Go code for a single node (for testing)
func (g *Generator) GenerateNode(node parser.Node) string {
	g.output.Reset()
	g.generateNode(node, "b")
	return g.output.String()
}

func (g *Generator) generateComponent(comp *parser.Component) {
	// Track current function's parameters for reference resolution
	g.currentParams = make(map[string]bool)
	g.objectParams = make(map[string]bool)
	for _, prop := range comp.Props {
		g.currentParams[prop.Name] = true
		g.currentParams[toCamelCase(prop.Name)] = true
		// Track object-like props
		if isObjectLikeName(strings.ToLower(prop.Name)) {
			g.objectParams[prop.Name] = true
			g.objectParams[toCamelCase(prop.Name)] = true
		}
	}
	// Also track state variables as known identifiers
	for _, sv := range comp.StateVars {
		g.currentParams[sv.Name] = true
		g.currentParams[toCamelCase(sv.Name)] = true
	}
	// Also track derived variables as known identifiers
	for _, dv := range comp.DerivedVars {
		g.currentParams[dv.Name] = true
		g.currentParams[toCamelCase(dv.Name)] = true
	}
	defer func() { g.currentParams = nil; g.objectParams = nil }()

	// Convert props to Go function parameters
	params := g.generateParams(comp.Props)
	
	// Add state variables as additional parameters
	stateParams := g.generateStateParams(comp.StateVars)
	if params != "" && stateParams != "" {
		params = params + ", " + stateParams
	} else if stateParams != "" {
		params = stateParams
	}

	// Write function signature
	g.writef("// %s component\n", comp.Name)

	// Add setter notes as comments (for HTMX conversion guidance)
	if len(comp.StateVars) > 0 {
		g.writeln("// State converted to parameters. Original setters:")
		for _, sv := range comp.StateVars {
			g.writef("//   %s → use HTMX to update %s parameter\n", sv.Setter, sv.Name)
		}
	}

	g.writef("func %s(%s) mi.H {\n", comp.Name, params)
	g.indent++

	// Generate derived variable declarations
	if len(comp.DerivedVars) > 0 {
		g.writeln("// Derived state - compute before render")
		for _, dv := range comp.DerivedVars {
			g.generateDerivedVar(dv)
		}
		g.writeln("")
	}

	g.writeIndent()
	g.write("return func(b *mi.Builder) mi.Node {\n")
	g.indent++

	if comp.Body != nil {
		g.writeIndent()
		g.write("return ")
		g.generateNode(comp.Body, "b")
		g.write("\n")
	} else {
		g.writeIndent()
		g.write("return nil // TODO: Component body not parsed\n")
	}

	g.indent--
	g.writeIndent()
	g.write("}\n")

	g.indent--
	g.write("}\n")
}

// generateDerivedVar generates Go code for a derived variable
func (g *Generator) generateDerivedVar(dv parser.DerivedVariable) {
	goName := toCamelCase(dv.Name)
	sourceVar := toCamelCase(dv.SourceVar)
	
	// Check if source is known
	sourceKnown := g.currentParams != nil && g.currentParams[dv.SourceVar]
	
	g.writeIndent()
	
	switch dv.Operation {
	case "filter":
		if sourceKnown {
			g.writef("var %s %s // TODO: implement filter\n", goName, dv.ResultType)
			g.writeIndent()
			g.writef("for _, item := range %s {\n", sourceVar)
			g.indent++
			g.writeIndent()
			g.writeln("// TODO: add filter condition")
			g.writeIndent()
			g.writef("// Original: %s\n", truncateExpr(dv.Expression, 60))
			g.writeIndent()
			g.writef("%s = append(%s, item)\n", goName, goName)
			g.indent--
			g.writeIndent()
			g.writeln("}")
		} else {
			g.writef("var %s %s // TODO: %s.filter(...)\n", goName, dv.ResultType, dv.SourceVar)
		}
		
	case "map":
		if sourceKnown {
			g.writef("var %s %s // TODO: implement map transformation\n", goName, dv.ResultType)
			g.writeIndent()
			g.writef("for _, item := range %s {\n", sourceVar)
			g.indent++
			g.writeIndent()
			g.writef("// Original: %s\n", truncateExpr(dv.Expression, 60))
			g.writeIndent()
			g.writef("%s = append(%s, item) // TODO: transform item\n", goName, goName)
			g.indent--
			g.writeIndent()
			g.writeln("}")
		} else {
			g.writef("var %s %s // TODO: %s.map(...)\n", goName, dv.ResultType, dv.SourceVar)
		}
		
	case "find":
		if sourceKnown {
			g.writef("var %s %s // TODO: implement find\n", goName, dv.ResultType)
			g.writeIndent()
			g.writef("for _, item := range %s {\n", sourceVar)
			g.indent++
			g.writeIndent()
			g.writef("// Original: %s\n", truncateExpr(dv.Expression, 60))
			g.writeIndent()
			g.writeln("if true /* TODO: condition */ {")
			g.indent++
			g.writeIndent()
			g.writef("%s = item\n", goName)
			g.writeIndent()
			g.writeln("break")
			g.indent--
			g.writeIndent()
			g.writeln("}")
			g.indent--
			g.writeIndent()
			g.writeln("}")
			g.writeIndent()
			g.writef("_ = %s // silence unused warning\n", goName)
		} else {
			g.writef("var %s %s // TODO: %s.find(...)\n", goName, dv.ResultType, dv.SourceVar)
			g.writeIndent()
			g.writef("_ = %s\n", goName)
		}
		
	case "some":
		if sourceKnown {
			g.writef("%s := false // TODO: implement some\n", goName)
			g.writeIndent()
			g.writef("for _, item := range %s {\n", sourceVar)
			g.indent++
			g.writeIndent()
			g.writef("_ = item // Original: %s\n", truncateExpr(dv.Expression, 50))
			g.writeIndent()
			g.writeln("if true /* TODO: condition */ {")
			g.indent++
			g.writeIndent()
			g.writef("%s = true\n", goName)
			g.writeIndent()
			g.writeln("break")
			g.indent--
			g.writeIndent()
			g.writeln("}")
			g.indent--
			g.writeIndent()
			g.writeln("}")
		} else {
			g.writef("%s := false // TODO: %s.some(...)\n", goName, dv.SourceVar)
		}
		
	case "every":
		if sourceKnown {
			g.writef("%s := true // TODO: implement every\n", goName)
			g.writeIndent()
			g.writef("for _, item := range %s {\n", sourceVar)
			g.indent++
			g.writeIndent()
			g.writef("_ = item // Original: %s\n", truncateExpr(dv.Expression, 50))
			g.writeIndent()
			g.writeln("if false /* TODO: !condition */ {")
			g.indent++
			g.writeIndent()
			g.writef("%s = false\n", goName)
			g.writeIndent()
			g.writeln("break")
			g.indent--
			g.writeIndent()
			g.writeln("}")
			g.indent--
			g.writeIndent()
			g.writeln("}")
		} else {
			g.writef("%s := true // TODO: %s.every(...)\n", goName, dv.SourceVar)
		}
		
	case "reduce":
		g.writef("var %s %s // TODO: implement reduce from %s\n", goName, dv.ResultType, dv.SourceVar)
		g.writeIndent()
		g.writef("// Original: %s\n", truncateExpr(dv.Expression, 60))
		g.writeIndent()
		g.writef("_ = %s // silence unused warning\n", goName)
		
	case "sort", "slice":
		if sourceKnown {
			g.writef("%s := make(%s, len(%s))\n", goName, dv.ResultType, sourceVar)
			g.writeIndent()
			g.writef("copy(%s, %s)\n", goName, sourceVar)
			if dv.Operation == "sort" {
				g.writeIndent()
				g.writef("// TODO: sort.Slice(%s, func(i, j int) bool { ... })\n", goName)
			}
		} else {
			g.writef("var %s %s // TODO: %s.%s(...)\n", goName, dv.ResultType, dv.SourceVar, dv.Operation)
		}
		
	default:
		g.writef("var %s %s // TODO: derived from %s\n", goName, dv.ResultType, dv.SourceVar)
	}
}

// truncateExpr truncates an expression for display in comments
func truncateExpr(expr string, maxLen int) string {
	// Remove newlines
	expr = strings.ReplaceAll(expr, "\n", " ")
	expr = strings.ReplaceAll(expr, "\t", " ")
	// Collapse whitespace
	for strings.Contains(expr, "  ") {
		expr = strings.ReplaceAll(expr, "  ", " ")
	}
	if len(expr) > maxLen {
		return expr[:maxLen-3] + "..."
	}
	return expr
}

// generateStateParams converts StateVariables to Go function parameters
func (g *Generator) generateStateParams(stateVars []parser.StateVariable) string {
	if len(stateVars) == 0 {
		return ""
	}
	
	var params []string
	for _, sv := range stateVars {
		name := toCamelCase(sv.Name)
		typ := sv.InitType
		if typ == "" {
			typ = "interface{}"
		}
		params = append(params, fmt.Sprintf("%s %s", name, typ))
	}
	return strings.Join(params, ", ")
}

func (g *Generator) generateParams(props []parser.Prop) string {
	if len(props) == 0 {
		return ""
	}

	var params []string
	for _, prop := range props {
		name := toCamelCase(prop.Name)
		
		// Infer type from name or default value
		typ := "string" // default to string for most props
		
		// Common naming patterns
		lowerName := strings.ToLower(prop.Name)
		if strings.Contains(lowerName, "items") || strings.Contains(lowerName, "list") || 
			strings.Contains(lowerName, "data") || strings.HasSuffix(lowerName, "s") && 
			!strings.HasSuffix(lowerName, "ss") && len(lowerName) > 3 {
			// Plural names suggest arrays
			typ = "[]interface{}"
		} else if strings.Contains(lowerName, "onclick") || strings.Contains(lowerName, "handler") || strings.Contains(lowerName, "callback") {
			// Skip event handlers - they'll be converted to HTMX
			continue
		} else if isBooleanPropName(prop.Name) { // use original case for camelCase detection
			typ = "bool"
		} else if strings.Contains(lowerName, "count") || strings.Contains(lowerName, "index") || strings.Contains(lowerName, "num") || strings.Contains(lowerName, "size") {
			typ = "int"
		} else if lowerName == "children" {
			typ = "mi.H"
		} else if isObjectLikeName(lowerName) {
			// Singular object-like names suggest struct/map types
			typ = "map[string]interface{}"
		}
		
		// Override with default value if present
		if prop.DefaultValue != "" {
			if prop.DefaultValue == "true" || prop.DefaultValue == "false" {
				typ = "bool"
			} else if _, err := fmt.Sscanf(prop.DefaultValue, "%d", new(int)); err == nil {
				typ = "int"
			}
		}
		
		params = append(params, fmt.Sprintf("%s %s", name, typ))
	}

	return strings.Join(params, ", ")
}

// isObjectLikeName checks if the prop name suggests an object/struct type
func isObjectLikeName(name string) bool {
	// Common singular object names
	objectNames := []string{
		"post", "user", "item", "task", "product", "article", "comment", 
		"message", "notification", "event", "order", "customer", "employee",
		"record", "entry", "document", "file", "image", "video", "audio",
		"config", "settings", "options", "params", "props", "state",
		"result", "response", "request", "error", "data", "info",
	}
	for _, objName := range objectNames {
		if name == objName {
			return true
		}
	}
	return false
}

// isBooleanPropName checks if prop name suggests a boolean type
// More careful than simple Contains to avoid false positives like "activeTab"
func isBooleanPropName(name string) bool {
	// Exact matches
	boolNames := []string{"active", "disabled", "enabled", "visible", "hidden", "open", "closed", "selected", "checked", "loading", "error"}
	for _, bn := range boolNames {
		if name == bn {
			return true
		}
	}
	
	// Prefix patterns: isX, hasX, showX, canX
	prefixes := []string{"is", "has", "show", "can", "should", "will", "did"}
	for _, prefix := range prefixes {
		if strings.HasPrefix(name, prefix) && len(name) > len(prefix) {
			// Check next char is uppercase (camelCase) or underscore
			nextChar := name[len(prefix)]
			if nextChar >= 'A' && nextChar <= 'Z' {
				return true
			}
			if nextChar == '_' {
				return true
			}
		}
	}
	
	return false
}

func (g *Generator) generateNode(node parser.Node, builder string) {
	if node == nil {
		g.write("nil")
		return
	}

	switch n := node.(type) {
	case *parser.Element:
		g.generateElement(n, builder)
	case *parser.Text:
		g.generateText(n)
	case *parser.Expression:
		g.generateExpression(n)
	case *parser.Fragment:
		g.generateFragment(n, builder)
	case *parser.MapExpr:
		g.generateMap(n, builder)
	case *parser.Conditional:
		g.generateConditional(n, builder)
	case *parser.Ternary:
		g.generateTernary(n, builder)
	default:
		g.writef("nil /* TODO: unhandled node type */")
	}
}

func (g *Generator) generateElement(elem *parser.Element, builder string) {
	tag := elem.Tag
	method := tagToMethod(tag)

	// Check if it's a component reference (PascalCase)
	if isComponentRef(tag) {
		g.writef("%s(%s)", tag, g.generateComponentArgs(elem))
		return
	}

	g.writef("%s.%s(", builder, method)

	// Generate attributes
	hasContent := false
	for _, attr := range elem.Attributes {
		// Skip key attribute (not needed in Go)
		if attr.Name == "key" {
			continue
		}
		
		// Handle event handlers → HTMX
		if attr.EventHandler != nil {
			if hasContent {
				g.write(",\n")
				g.writeIndent()
				g.write("\t")
			}
			g.generateEventHandler(attr.EventHandler, elem.Tag)
			hasContent = true
			continue
		}
		
		if hasContent {
			g.write(", ")
		}
		g.generateAttribute(&attr)
		hasContent = true
	}

	// Generate children
	for i, child := range elem.Children {
		if hasContent || i > 0 {
			g.write(",\n")
			g.writeIndent()
			g.write("\t")
		}
		g.generateNode(child, builder)
		hasContent = true
	}

	g.write(")")
}

// generateEventHandler generates HTMX attributes for a React event handler
func (g *Generator) generateEventHandler(handler *parser.EventHandler, tag string) {
	// Determine HTMX method based on event type and context
	switch handler.EventType {
	case "onClick":
		g.generateOnClick(handler, tag)
	case "onChange":
		g.generateOnChange(handler, tag)
	case "onSubmit":
		g.generateOnSubmit(handler)
	case "onInput":
		g.generateOnInput(handler)
	case "onBlur":
		g.generateOnBlur(handler)
	case "onFocus":
		g.write("/* TODO: onFocus - consider mi.HtmxTrigger(\"focus\") */")
	case "onKeyDown", "onKeyUp", "onKeyPress":
		g.writef("/* TODO: %s - consider mi.HtmxTrigger(\"keyup\") with key filter */", handler.EventType)
	case "onMouseEnter", "onMouseLeave", "onMouseOver":
		g.writef("/* TODO: %s - consider mi.HtmxTrigger(\"%s\") */", 
			handler.EventType, strings.ToLower(strings.TrimPrefix(handler.EventType, "on")))
	default:
		g.writef("/* TODO: %s handler */", handler.EventType)
	}
}

// generateOnClick generates HTMX for onClick handlers
func (g *Generator) generateOnClick(handler *parser.EventHandler, tag string) {
	// Check for simple setState patterns
	if len(handler.SetterCalls) == 1 {
		setter := handler.SetterCalls[0]
		stateName := strings.TrimPrefix(setter, "set")
		stateName = strings.ToLower(stateName[:1]) + stateName[1:]
		
		// Check for toggle pattern: setX(!x) or setX(prev => !prev)
		if strings.Contains(handler.HandlerBody, "!"+stateName) || 
			strings.Contains(handler.HandlerBody, "!prev") ||
			strings.Contains(handler.HandlerBody, "=> !") {
			g.writef("mi.HtmxPost(\"/toggle-%s\")", toKebabCase(stateName))
			g.write(", mi.HtmxSwap(\"outerHTML\")")
			g.writef(" /* %s toggles %s */", setter, stateName)
			return
		}
		
		// Check for simple value set: setX('value') or setX(value)
		valuePattern := regexp.MustCompile(setter + `\s*\(\s*['"]?([^'")\s]+)['"]?\s*\)`)
		if matches := valuePattern.FindStringSubmatch(handler.HandlerBody); matches != nil {
			value := matches[1]
			g.writef("mi.HtmxPost(\"/%s?%s=%s\")", toKebabCase(stateName), stateName, value)
			g.write(", mi.HtmxSwap(\"outerHTML\")")
			g.writef(" /* %s(%s) */", setter, value)
			return
		}
		
		// Generic setter call
		g.writef("mi.HtmxPost(\"/update-%s\")", toKebabCase(stateName))
		g.write(", mi.HtmxSwap(\"outerHTML\")")
		g.writef(" /* TODO: %s */", handler.HandlerBody)
		return
	}
	
	// Multiple setters or complex logic
	if len(handler.SetterCalls) > 1 {
		g.write("mi.HtmxPost(\"/action\")")
		g.write(", mi.HtmxSwap(\"outerHTML\")")
		g.writef(" /* TODO: complex handler with %v */", handler.SetterCalls)
		return
	}
	
	// No setters - might be navigation or other action
	if strings.Contains(handler.HandlerBody, "navigate") || 
		strings.Contains(handler.HandlerBody, "router") ||
		strings.Contains(handler.HandlerBody, "history") {
		g.write("/* TODO: navigation - use <a href=\"...\"> instead */")
		return
	}
	
	g.writef("mi.HtmxPost(\"/click-action\") /* TODO: %s */", truncateExpr(handler.HandlerBody, 40))
}

// generateOnChange generates HTMX for onChange handlers (typically for inputs)
func (g *Generator) generateOnChange(handler *parser.EventHandler, tag string) {
	// Check for simple setState with e.target.value
	if len(handler.SetterCalls) == 1 && 
		(strings.Contains(handler.HandlerBody, "target.value") ||
		 strings.Contains(handler.HandlerBody, "target.checked")) {
		setter := handler.SetterCalls[0]
		stateName := strings.TrimPrefix(setter, "set")
		stateName = strings.ToLower(stateName[:1]) + stateName[1:]
		
		if tag == "input" || tag == "textarea" || tag == "select" {
			g.writef("mi.Name(%q)", stateName)
			g.write(", mi.HtmxGet(\"/update\")")
			g.writef(", mi.HtmxTrigger(\"input changed delay:300ms\")")
			g.write(", mi.HtmxInclude(\"closest form\")")
			g.writef(" /* %s from input */", setter)
			return
		}
	}
	
	// Checkbox/radio special handling
	if strings.Contains(handler.HandlerBody, "checked") {
		if len(handler.SetterCalls) == 1 {
			setter := handler.SetterCalls[0]
			stateName := strings.TrimPrefix(setter, "set")
			stateName = strings.ToLower(stateName[:1]) + stateName[1:]
			g.writef("mi.Name(%q)", stateName)
			g.write(", mi.HtmxPost(\"/toggle\")")
			g.write(", mi.HtmxTrigger(\"change\")")
			g.writef(" /* %s from checkbox */", setter)
			return
		}
	}
	
	g.writef("mi.HtmxGet(\"/update\"), mi.HtmxTrigger(\"change\") /* TODO: %s */", 
		truncateExpr(handler.HandlerBody, 40))
}

// generateOnSubmit generates HTMX for form submissions
func (g *Generator) generateOnSubmit(handler *parser.EventHandler) {
	// Most form submissions prevent default and do something
	if strings.Contains(handler.HandlerBody, "preventDefault") {
		g.write("mi.HtmxPost(\"/submit\")")
		g.write(", mi.HtmxSwap(\"outerHTML\")")
		if len(handler.SetterCalls) > 0 {
			g.writef(" /* updates: %v */", handler.SetterCalls)
		}
		return
	}
	
	g.writef("mi.HtmxPost(\"/submit\") /* TODO: %s */", truncateExpr(handler.HandlerBody, 40))
}

// generateOnInput generates HTMX for onInput handlers
func (g *Generator) generateOnInput(handler *parser.EventHandler) {
	if len(handler.SetterCalls) == 1 {
		setter := handler.SetterCalls[0]
		stateName := strings.TrimPrefix(setter, "set")
		stateName = strings.ToLower(stateName[:1]) + stateName[1:]
		g.writef("mi.Name(%q)", stateName)
		g.write(", mi.HtmxGet(\"/search\")")
		g.write(", mi.HtmxTrigger(\"input changed delay:200ms\")")
		g.writef(" /* live %s */", setter)
		return
	}
	
	g.write("mi.HtmxGet(\"/update\"), mi.HtmxTrigger(\"input\")")
}

// generateOnBlur generates HTMX for onBlur handlers
func (g *Generator) generateOnBlur(handler *parser.EventHandler) {
	if len(handler.SetterCalls) == 1 {
		setter := handler.SetterCalls[0]
		stateName := strings.TrimPrefix(setter, "set")
		stateName = strings.ToLower(stateName[:1]) + stateName[1:]
		g.writef("mi.Name(%q)", stateName)
		g.write(", mi.HtmxPost(\"/validate\")")
		g.write(", mi.HtmxTrigger(\"blur\")")
		g.writef(" /* validate %s */", stateName)
		return
	}
	
	g.write("mi.HtmxPost(\"/validate\"), mi.HtmxTrigger(\"blur\")")
}

// toKebabCase converts camelCase to kebab-case
func toKebabCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('-')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func (g *Generator) generateAttribute(attr *parser.Attribute) {
	if attr.IsSpread {
		g.writef("mi.Attr(\"spread\", \"\") /* TODO: {...%s} */", attr.SpreadExpr)
		return
	}

	name := attr.Name
	
	// Handle data attributes specially
	if strings.HasPrefix(name, "data-") {
		dataName := strings.TrimPrefix(name, "data-")
		if attr.Value != "" {
			g.writef("mi.Data(%q, %q)", dataName, attr.Value)
		} else if attr.Expression.Raw != "" {
			value := g.translateExprValue(attr.Expression.Raw)
			g.writef("mi.Data(%q, %s)", dataName, value)
		} else {
			g.writef("mi.Data(%q, \"\")", dataName)
		}
		return
	}
	
	// Handle aria attributes
	if strings.HasPrefix(name, "aria-") {
		if attr.Value != "" {
			g.writef("mi.Attr(%q, %q)", name, attr.Value)
		} else if attr.Expression.Raw != "" {
			value := g.translateExprValue(attr.Expression.Raw)
			// If this is a comparison (returns bool), wrap in fmt.Sprint for string
			if strings.Contains(value, "==") || strings.Contains(value, "!=") ||
				strings.Contains(value, ">") || strings.Contains(value, "<") {
				g.writef("mi.Attr(%q, fmt.Sprint(%s))", name, value)
			} else {
				g.writef("mi.Attr(%q, %s)", name, value)
			}
		} else {
			g.writef("mi.Attr(%q, \"\")", name)
		}
		return
	}
	
	mintyAttr := attrToMinty(name)

	// String value
	if attr.Value != "" {
		if mintyAttr != "" {
			g.writef("%s(%q)", mintyAttr, attr.Value)
		} else {
			g.writef("mi.Attr(%q, %q)", name, attr.Value)
		}
		return
	}

	// Expression value
	if attr.Expression.Raw != "" {
		value := g.translateExprValue(attr.Expression.Raw)
		if mintyAttr != "" {
			// Check if this is a no-argument boolean attribute
			boolAttrs := map[string]bool{
				"mi.Disabled": true, "mi.Readonly": true, "mi.Required": true,
				"mi.Checked": true, "mi.Selected": true, "mi.Multiple": true,
				"mi.Autofocus": true, "mi.Autoplay": true, "mi.Controls": true,
				"mi.Loop": true, "mi.Muted": true, "mi.NoValidate": true,
				"mi.Open": true, "mi.Reversed": true, "mi.Async": true,
				"mi.Defer": true, "mi.Hidden": true,
			}
			if boolAttrs[mintyAttr] {
				// Boolean attr with condition - use conditional inclusion
				g.writef("/* conditional: %s when %s */ ", mintyAttr+"()", value)
				g.writef("mi.Attr(%q, fmt.Sprint(%s))", name, value)
			} else {
				g.writef("%s(%s)", mintyAttr, value)
			}
		} else {
			g.writef("mi.Attr(%q, %s)", name, value)
		}
		return
	}

	// Boolean attribute
	if mintyAttr != "" {
		// Some functions like mi.Class require an argument
		if mintyAttr == "mi.Class" {
			g.writef("%s(\"\")", mintyAttr)
		} else {
			g.writef("%s()", mintyAttr)
		}
	} else {
		g.writef("mi.Attr(%q, \"\")", name)
	}
}

func (g *Generator) translateExprValue(expr string) string {
	// Ternary expression → mi.Ternary (for string results)
	if strings.Contains(expr, "?") && strings.Contains(expr, ":") {
		if translated := g.translateTernaryExpr(expr); translated != "" {
			return translated
		}
	}

	// Template literal → fmt.Sprintf
	if strings.Contains(expr, "`") || strings.Contains(expr, "${") {
		return g.translateTemplateLiteral(expr)
	}

	// Simple identifier - check if it's a known parameter
	if isSimpleIdent(expr) {
		goName := toCamelCase(expr)
		if g.currentParams != nil && g.currentParams[expr] {
			return goName
		}
		// Unknown variable - placeholder
		return fmt.Sprintf("\"\" /* TODO: %s */", expr)
	}

	// Property access: item.name, props.value, etc.
	if isPropertyAccess(expr) {
		parts := strings.Split(expr, ".")
		base := parts[0]
		
		// If we're in a map body and this is the item variable, use mi.Str
		if g.inMapBody && len(parts) >= 2 && base == g.currentItemVar {
			fieldName := parts[1]
			return fmt.Sprintf("mi.Str(%s, %q)", base, fieldName)
		}
		
		// If the base is an object-like param, use mi.Str
		if g.objectParams != nil && g.objectParams[base] && len(parts) >= 2 {
			fieldName := parts[1]
			return fmt.Sprintf("mi.Str(%s, %q)", base, fieldName)
		}
		
		// Otherwise wrap as placeholder
		return fmt.Sprintf("\"\" /* TODO: %s */", expr)
	}

	// Comparison expression - try to translate
	if strings.Contains(expr, "===") || strings.Contains(expr, "==") ||
		strings.Contains(expr, "!==") || strings.Contains(expr, "!=") {
		if translated := g.translateComparison(expr); translated != "" {
			return translated
		}
	}

	// Length check - try to translate
	if strings.Contains(expr, ".length") {
		if translated := g.translateLengthExpr(expr); translated != "" {
			return translated
		}
	}

	// Comparison with < > (might be length check)
	if strings.Contains(expr, ">") || strings.Contains(expr, "<") {
		if translated := g.translateLengthExpr(expr); translated != "" {
			return translated
		}
		return fmt.Sprintf("\"\" /* TODO: %s */", strings.ReplaceAll(expr, "\"", "'"))
	}

	// Arrow function - produce empty string placeholder
	if strings.Contains(expr, "=>") {
		return fmt.Sprintf("\"\" /* TODO: %s */", strings.ReplaceAll(expr, "\"", "'"))
	}

	// String concatenation
	if strings.Contains(expr, "+") {
		return fmt.Sprintf("\"\" /* TODO: %s */", strings.ReplaceAll(expr, "\"", "'"))
	}

	// Function call
	if strings.Contains(expr, "(") {
		return fmt.Sprintf("\"\" /* TODO: %s */", strings.ReplaceAll(expr, "\"", "'"))
	}

	return fmt.Sprintf("%q", expr)
}

// translateTernaryExpr translates a ternary expression to Go
// e.g., "filter === 'all' ? 'active' : ''" → func() string { if filter == "all" { return "active" }; return "" }()
func (g *Generator) translateTernaryExpr(expr string) string {
	// Find the ? and : positions
	qPos := strings.Index(expr, "?")
	if qPos < 0 {
		return ""
	}
	
	// Find the matching : (handle nested ternaries by counting)
	colonPos := -1
	depth := 0
	for i := qPos + 1; i < len(expr); i++ {
		if expr[i] == '?' {
			depth++
		} else if expr[i] == ':' {
			if depth == 0 {
				colonPos = i
				break
			}
			depth--
		}
	}
	
	if colonPos < 0 {
		return ""
	}
	
	condition := strings.TrimSpace(expr[:qPos])
	consequent := strings.TrimSpace(expr[qPos+1 : colonPos])
	alternate := strings.TrimSpace(expr[colonPos+1:])
	
	// Translate the condition (=== to ==, !== to !=)
	goCondition := g.translateComparison(condition)
	if goCondition == "" {
		// Try as-is but fix operators
		goCondition = strings.ReplaceAll(condition, "===", "==")
		goCondition = strings.ReplaceAll(goCondition, "!==", "!=")
	}
	
	// Extract string values from consequent/alternate
	goConsequent := extractStringValue(consequent)
	goAlternate := extractStringValue(alternate)
	
	// Generate inline Go ternary equivalent
	return fmt.Sprintf("func() string { if %s { return %s }; return %s }()", goCondition, goConsequent, goAlternate)
}

// extractStringValue extracts a Go string from a JS value
func extractStringValue(val string) string {
	val = strings.TrimSpace(val)
	
	// Already quoted with single quotes
	if len(val) >= 2 && val[0] == '\'' && val[len(val)-1] == '\'' {
		inner := val[1 : len(val)-1]
		return fmt.Sprintf("%q", inner)
	}
	
	// Already quoted with double quotes
	if len(val) >= 2 && val[0] == '"' && val[len(val)-1] == '"' {
		return val
	}
	
	// Empty string representations
	if val == "''" || val == "\"\"" {
		return `""`
	}
	
	// It's a variable reference
	return val
}

// translateComparison translates JS comparison to Go
// e.g., "activeTab === 'all'" → "activeTab == \"all\""
func (g *Generator) translateComparison(expr string) string {
	// Try to parse: variable === 'value' or variable === "value"
	// Also: variable !== 'value'
	
	var op, goOp string
	if strings.Contains(expr, "===") {
		op = "==="
		goOp = "=="
	} else if strings.Contains(expr, "!==") {
		op = "!=="
		goOp = "!="
	} else if strings.Contains(expr, "==") {
		op = "=="
		goOp = "=="
	} else if strings.Contains(expr, "!=") {
		op = "!="
		goOp = "!="
	} else {
		return ""
	}
	
	parts := strings.SplitN(expr, op, 2)
	if len(parts) != 2 {
		return ""
	}
	
	left := strings.TrimSpace(parts[0])
	right := strings.TrimSpace(parts[1])
	
	// Translate left side
	goLeft := g.translateComparisonOperand(left)
	if goLeft == "" {
		return ""
	}
	
	// Translate right side
	goRight := g.translateComparisonOperand(right)
	if goRight == "" {
		return ""
	}
	
	return fmt.Sprintf("%s %s %s", goLeft, goOp, goRight)
}

// translateComparisonOperand translates a single operand
func (g *Generator) translateComparisonOperand(operand string) string {
	operand = strings.TrimSpace(operand)
	
	// String literal with single quotes → double quotes
	if strings.HasPrefix(operand, "'") && strings.HasSuffix(operand, "'") {
		inner := operand[1 : len(operand)-1]
		return fmt.Sprintf("%q", inner)
	}
	
	// String literal with double quotes
	if strings.HasPrefix(operand, "\"") && strings.HasSuffix(operand, "\"") {
		return operand
	}
	
	// Boolean literal
	if operand == "true" || operand == "false" {
		return operand
	}
	
	// Number literal
	if _, err := strconv.Atoi(operand); err == nil {
		return operand
	}
	if _, err := strconv.ParseFloat(operand, 64); err == nil {
		return operand
	}
	
	// null/undefined → nil
	if operand == "null" || operand == "undefined" {
		return "nil"
	}
	
	// Simple identifier - check if known
	if isSimpleIdent(operand) {
		goName := toCamelCase(operand)
		if g.currentParams != nil && g.currentParams[operand] {
			return goName
		}
		// Unknown variable - can't translate
		return ""
	}
	
	// Property access in map body
	if isPropertyAccess(operand) && g.inMapBody {
		parts := strings.Split(operand, ".")
		if len(parts) >= 2 && parts[0] == g.currentItemVar {
			return fmt.Sprintf("%s[%q]", parts[0], parts[1])
		}
	}
	
	return ""
}

// translateLengthExpr translates .length expressions to len()
// e.g., "items.length > 0" → "len(items) > 0"
// e.g., "items.length" → "len(items)" (plain length)
func (g *Generator) translateLengthExpr(expr string) string {
	// Pattern: something.length > 0, something.length === 0, etc.
	
	// Find .length
	lengthIdx := strings.Index(expr, ".length")
	if lengthIdx == -1 {
		return ""
	}
	
	// Extract the variable before .length
	varPart := strings.TrimSpace(expr[:lengthIdx])
	afterLength := strings.TrimSpace(expr[lengthIdx+7:]) // 7 = len(".length")
	
	// Translate the variable
	var goVar string
	if isSimpleIdent(varPart) {
		goName := toCamelCase(varPart)
		if g.currentParams != nil && g.currentParams[varPart] {
			goVar = goName
		}
	}
	
	if goVar == "" {
		// Check if it's a known derived variable (like sortedPosts, filteredPosts)
		goName := toCamelCase(varPart)
		if g.currentParams != nil && g.currentParams[varPart] {
			goVar = goName
		} else {
			// Common derived variable names - allow them
			commonDerived := []string{"sortedPosts", "filteredPosts", "filteredItems", "sortedItems", "results"}
			for _, d := range commonDerived {
				if goName == d {
					goVar = goName
					break
				}
			}
		}
	}
	
	if goVar == "" {
		// Unknown variable - can't fully translate but show pattern
		return fmt.Sprintf("len(%s) %s /* TODO: verify %s */", varPart, afterLength, varPart)
	}
	
	// If no comparison after .length, just return len(var)
	if afterLength == "" {
		return fmt.Sprintf("len(%s)", goVar)
	}
	
	// Parse the rest: > 0, === 0, >= 1, etc.
	afterLength = strings.ReplaceAll(afterLength, "===", "==")
	afterLength = strings.ReplaceAll(afterLength, "!==", "!=")
	
	return fmt.Sprintf("len(%s) %s", goVar, afterLength)
}

// translateTemplateLiteral converts JS template literals to fmt.Sprintf
func (g *Generator) translateTemplateLiteral(expr string) string {
	// Remove backticks if present
	expr = strings.Trim(expr, "`")
	
	// Find all ${...} patterns
	var vars []string
	result := expr
	
	for {
		start := strings.Index(result, "${")
		if start == -1 {
			break
		}
		end := strings.Index(result[start:], "}")
		if end == -1 {
			break
		}
		end += start
		
		varName := result[start+2 : end]
		
		// Handle property access (e.g., post.status)
		if strings.Contains(varName, ".") {
			parts := strings.Split(varName, ".")
			if len(parts) >= 2 {
				base := parts[0]
				field := parts[1]
				// Check if base is an object-like parameter or map item
				if g.objectParams != nil && g.objectParams[base] {
					vars = append(vars, fmt.Sprintf("mi.Str(%s, %q)", base, field))
				} else if g.inMapBody && base == g.currentItemVar {
					vars = append(vars, fmt.Sprintf("mi.Str(%s, %q)", base, field))
				} else if g.currentParams != nil && g.currentParams[base] {
					// Known param but not object-like, try mi.Str
					vars = append(vars, fmt.Sprintf("mi.Str(%s, %q)", base, field))
				} else {
					vars = append(vars, varName) // keep as-is for unknown
				}
			} else {
				vars = append(vars, toCamelCase(varName))
			}
		} else {
			vars = append(vars, toCamelCase(varName))
		}
		result = result[:start] + "%v" + result[end+1:]
	}
	
	if len(vars) == 0 {
		// No interpolation found, just return as string
		return fmt.Sprintf("%q", expr)
	}
	
	return fmt.Sprintf("fmt.Sprintf(%q, %s)", result, strings.Join(vars, ", "))
}

func isPropertyAccess(s string) bool {
	// Check if it's something like "item.id" or "user.name.first"
	if !strings.Contains(s, ".") {
		return false
	}
	parts := strings.Split(s, ".")
	for _, part := range parts {
		if !isSimpleIdent(part) {
			return false
		}
	}
	return true
}

func (g *Generator) generateText(text *parser.Text) {
	// Escape the text content
	g.writef("%q", text.Content)
}

func (g *Generator) generateExpression(expr *parser.Expression) {
	// Simple variable reference
	if isSimpleIdent(expr.Raw) {
		goName := toCamelCase(expr.Raw)
		if g.currentParams != nil && g.currentParams[expr.Raw] {
			g.write(goName)
			return
		}
		// Unknown variable - placeholder
		g.writef("\"\" /* TODO: %s */", expr.Raw)
		return
	}

	// Property access: item.name
	// But first check for .length which is special
	if isPropertyAccess(expr.Raw) {
		parts := strings.Split(expr.Raw, ".")
		base := parts[0]
		
		// Special case: .length - convert to len()
		if len(parts) == 2 && parts[1] == "length" {
			// Check if base is a known variable
			if g.currentParams != nil && g.currentParams[base] {
				goBase := toCamelCase(base)
				g.writef("len(%s)", goBase)
				return
			}
		}
		
		// If we're in a map body and this is the item variable, use mi.Str
		if g.inMapBody && len(parts) >= 2 && base == g.currentItemVar {
			fieldName := parts[1]
			g.writef("mi.Str(%s, %q)", base, fieldName)
			return
		}
		
		// If the base is an object-like param, use mi.Str
		if g.objectParams != nil && g.objectParams[base] && len(parts) >= 2 {
			fieldName := parts[1]
			g.writef("mi.Str(%s, %q)", base, fieldName)
			return
		}
		
		// Otherwise placeholder
		g.writef("\"\" /* TODO: %s */", expr.Raw)
		return
	}

	// More complex expression - show as string placeholder
	g.writef("\"\" /* TODO: %s */", expr.Raw)
}

func (g *Generator) generateFragment(frag *parser.Fragment, builder string) {
	g.usesFragment = true

	if len(frag.Children) == 0 {
		g.write("mi.NewFragment()")
		return
	}

	g.write("mi.NewFragment(")
	for i, child := range frag.Children {
		if i > 0 {
			g.write(",")
			g.writeln("")
			g.writeIndent()
		}
		g.generateNode(child, builder)
	}
	g.write(")")
}

func (g *Generator) generateMap(m *parser.MapExpr, builder string) {
	g.usesEach = true

	collection := toCamelCase(m.Collection)
	itemVar := m.ItemVar
	
	// Check if collection is a known parameter
	collectionKnown := g.currentParams != nil && g.currentParams[m.Collection]
	
	// Use mi.Each with interface{}
	if m.IndexVar != "" {
		if collectionKnown {
			g.writef("mi.EachWithIndex(%s, func(%s int, %sVal interface{}) mi.H {\n",
				collection,
				m.IndexVar,
				itemVar)
		} else {
			// Collection is undefined - create placeholder
			g.writef("mi.EachWithIndex([]interface{}{} /* TODO: %s */, func(%s int, %sVal interface{}) mi.H {\n",
				m.Collection,
				m.IndexVar,
				itemVar)
		}
	} else {
		if collectionKnown {
			g.writef("mi.Each(%s, func(%sVal interface{}) mi.H {\n",
				collection,
				itemVar)
		} else {
			// Collection is undefined - create placeholder
			g.writef("mi.Each([]interface{}{} /* TODO: %s */, func(%sVal interface{}) mi.H {\n",
				m.Collection,
				itemVar)
		}
	}
	g.indent++
	
	// Add type assertion that produces a map for field access
	g.writeIndent()
	g.writef("%s := %sVal.(map[string]interface{}) // TODO: or use your struct type\n", itemVar, itemVar)
	
	// Check if body is a component call (returns mi.H) vs a builder call (returns mi.Node)
	isComponentCall := false
	if elem, ok := m.Body.(*parser.Element); ok {
		isComponentCall = isComponentName(elem.Tag)
	}
	
	if isComponentCall {
		// Component calls return mi.H directly
		g.writeIndent()
		g.write("return ")
		g.inMapBody = true
		g.currentItemVar = itemVar
		g.generateNode(m.Body, "b")
		g.inMapBody = false
		g.currentItemVar = ""
		g.write("\n")
	} else {
		// Builder calls need the func wrapper
		g.writeIndent()
		g.write("return func(b *mi.Builder) mi.Node {\n")
		g.indent++
		g.writeIndent()
		g.write("return ")
		if m.Body != nil {
			// Use a special context for map body generation
			g.inMapBody = true
			g.currentItemVar = itemVar
			g.generateNode(m.Body, "b")
			g.inMapBody = false
			g.currentItemVar = ""
		} else {
			g.write("nil /* TODO: map body not parsed */")
		}
		g.write("\n")
		g.indent--
		g.writeIndent()
		g.write("}\n")
	}
	g.indent--
	g.writeIndent()
	g.write("})")
}

func (g *Generator) generateConditional(c *parser.Conditional, builder string) {
	g.usesIf = true

	condition := g.translateCondition(c.Condition)
	g.writef("mi.If(%s, func(b *mi.Builder) mi.Node {\n", condition)
	g.indent++
	g.writeIndent()
	g.write("return ")
	g.generateNode(c.Consequent, builder)
	g.write("\n")
	g.indent--
	g.writeIndent()
	g.write("})")
}

func (g *Generator) generateTernary(t *parser.Ternary, builder string) {
	g.usesIfElse = true

	condition := g.translateCondition(t.Condition)
	g.writef("mi.IfElse(%s,\n", condition)
	g.indent++
	g.writeIndent()
	g.write("func(b *mi.Builder) mi.Node {\n")
	g.indent++
	
	// Check if consequent is a MapExpr - needs special handling for []Node -> Node
	if mapExpr, ok := t.Consequent.(*parser.MapExpr); ok {
		g.writeIndent()
		g.write("// Convert []Node to Node by wrapping in container\n")
		g.writeIndent()
		g.write("nodes := ")
		g.generateMap(mapExpr, builder)
		g.write("\n")
		g.writeIndent()
		g.write("children := make([]interface{}, len(nodes))\n")
		g.writeIndent()
		g.write("for i, n := range nodes { children[i] = n }\n")
		g.writeIndent()
		g.write("return b.Div(children...)\n")
	} else {
		g.writeIndent()
		g.write("return ")
		if t.Consequent != nil {
			// Check if consequent is just a string (failed parse)
			if text, ok := t.Consequent.(*parser.Text); ok && (text.Content == "(" || text.Content == ")") {
				g.write("nil /* TODO: ternary consequent */")
			} else {
				g.generateNode(t.Consequent, builder)
			}
		} else {
			g.write("nil /* TODO: ternary consequent */")
		}
		g.write("\n")
	}
	g.indent--
	g.writeIndent()
	g.write("},\n")
	g.writeIndent()
	g.write("func(b *mi.Builder) mi.Node {\n")
	g.indent++
	
	// Check if alternate is a MapExpr - needs special handling
	if mapExpr, ok := t.Alternate.(*parser.MapExpr); ok {
		g.writeIndent()
		g.write("// Convert []Node to Node by wrapping in container\n")
		g.writeIndent()
		g.write("nodes := ")
		g.generateMap(mapExpr, builder)
		g.write("\n")
		g.writeIndent()
		g.write("children := make([]interface{}, len(nodes))\n")
		g.writeIndent()
		g.write("for i, n := range nodes { children[i] = n }\n")
		g.writeIndent()
		g.write("return b.Div(children...)\n")
	} else {
		g.writeIndent()
		g.write("return ")
		if t.Alternate != nil {
			// Check if alternate is just a string (failed parse)
			if text, ok := t.Alternate.(*parser.Text); ok && (text.Content == "(" || text.Content == ")") {
				g.write("nil /* TODO: ternary alternate */")
			} else {
				g.generateNode(t.Alternate, builder)
			}
		} else {
			g.write("nil /* TODO: ternary alternate */")
		}
		g.write("\n")
	}
	g.indent--
	g.writeIndent()
	g.write("},\n")
	g.indent--
	g.writeIndent()
	g.write(")")
}

func (g *Generator) generateComponentArgs(elem *parser.Element) string {
	var args []string
	for _, attr := range elem.Attributes {
		if attr.IsSpread {
			continue
		}
		// Skip React-specific attributes
		if attr.Name == "key" || attr.Name == "ref" {
			continue
		}
		if attr.Value != "" {
			args = append(args, fmt.Sprintf("%q", attr.Value))
		} else if attr.Expression.Raw != "" {
			raw := attr.Expression.Raw
			
			// When in map body and the expression IS the item variable itself,
			// pass it directly (not as a property access)
			if g.inMapBody && raw == g.currentItemVar {
				args = append(args, g.currentItemVar)
				continue
			}
			
			// When in map body and accessing item properties, 
			// we can't know the target parameter type - infer from attr name
			if g.inMapBody && isPropertyAccess(raw) {
				parts := strings.Split(raw, ".")
				if len(parts) >= 2 && parts[0] == g.currentItemVar {
					fieldName := parts[1]
					attrName := strings.ToLower(attr.Name)
					
					// Infer type from attribute name
					if strings.HasPrefix(attrName, "is") || 
						strings.Contains(attrName, "active") ||
						strings.Contains(attrName, "enabled") ||
						strings.Contains(attrName, "disabled") ||
						strings.HasPrefix(attrName, "has") ||
						strings.Contains(attrName, "show") ||
						strings.Contains(attrName, "hidden") ||
						strings.Contains(attrName, "visible") {
						// Bool - use mi.Bool
						args = append(args, fmt.Sprintf("mi.Bool(%s, %q)", 
							parts[0], fieldName))
					} else if strings.Contains(attrName, "count") ||
						strings.Contains(attrName, "index") ||
						strings.Contains(attrName, "num") ||
						strings.Contains(attrName, "size") {
						// Int - use mi.Int
						args = append(args, fmt.Sprintf("mi.Int(%s, %q)",
							parts[0], fieldName))
					} else {
						// String - use mi.Str
						args = append(args, fmt.Sprintf("mi.Str(%s, %q)", 
							parts[0], fieldName))
					}
					continue
				}
			}
			args = append(args, g.translateExprValue(raw))
		}
	}
	return strings.Join(args, ", ")
}

func (g *Generator) translateCondition(cond string) string {
	cond = strings.TrimSpace(cond)
	
	// Simple identifier - likely a boolean parameter
	if isSimpleIdent(cond) {
		goName := toCamelCase(cond)
		if g.currentParams != nil && g.currentParams[cond] {
			return goName
		}
		// Unknown boolean - return false with TODO
		return fmt.Sprintf("false /* TODO: %s */", cond)
	}

	// Property access from props
	if strings.HasPrefix(cond, "props.") {
		return toCamelCase(strings.TrimPrefix(cond, "props."))
	}
	
	// Property access for truthy check: post.category, item.active
	if isPropertyAccess(cond) && !strings.Contains(cond, " ") {
		parts := strings.Split(cond, ".")
		if len(parts) >= 2 {
			base := parts[0]
			field := parts[1]
			// Check if base is known
			if g.inMapBody && base == g.currentItemVar {
				return fmt.Sprintf("mi.Truthy(%s[%q])", base, field)
			}
			if g.objectParams != nil && g.objectParams[base] {
				return fmt.Sprintf("mi.Truthy(%s[%q])", base, field)
			}
		}
	}
	
	// Numeric comparison: post.likes > 0, item.count >= 5
	if numMatch := regexp.MustCompile(`^(\w+(?:\.\w+)?)\s*(>|>=|<|<=)\s*(\d+)$`).FindStringSubmatch(cond); numMatch != nil {
		varExpr := numMatch[1]
		op := numMatch[2]
		val := numMatch[3]
		
		if isPropertyAccess(varExpr) {
			parts := strings.Split(varExpr, ".")
			if len(parts) >= 2 {
				base := parts[0]
				field := parts[1]
				// Check if base is known
				if (g.inMapBody && base == g.currentItemVar) || 
					(g.objectParams != nil && g.objectParams[base]) {
					// Use appropriate mi helper
					switch op {
					case ">":
						return fmt.Sprintf("mi.Gt(%s, %q, %s)", base, field, val)
					case ">=":
						return fmt.Sprintf("mi.Gte(%s, %q, %s)", base, field, val)
					case "<":
						return fmt.Sprintf("mi.Lt(%s, %q, %s)", base, field, val)
					case "<=":
						return fmt.Sprintf("mi.Lte(%s, %q, %s)", base, field, val)
					}
				}
			}
		}
	}

	// Length check: items.length > 0, etc.
	if strings.Contains(cond, ".length") {
		if translated := g.translateLengthExpr(cond); translated != "" {
			// Check if it contains TODO (meaning variable is unknown)
			if strings.Contains(translated, "/* TODO") {
				// Variable unknown - use false placeholder with original expression
				cleanCond := strings.ReplaceAll(cond, "\"", "'")
				return fmt.Sprintf("false /* TODO: %s */", cleanCond)
			}
			return translated
		}
	}

	// Comparison expression: x === 'value', etc.
	if strings.Contains(cond, "===") || strings.Contains(cond, "!==") ||
		strings.Contains(cond, "==") || strings.Contains(cond, "!=") {
		if translated := g.translateComparison(cond); translated != "" {
			return translated
		}
	}

	// Negation: !someVar
	if strings.HasPrefix(cond, "!") {
		inner := strings.TrimPrefix(cond, "!")
		if isSimpleIdent(inner) {
			goName := toCamelCase(inner)
			if g.currentParams != nil && g.currentParams[inner] {
				return "!" + goName
			}
		}
		// Property access negation: !post.active
		if isPropertyAccess(inner) {
			parts := strings.Split(inner, ".")
			if len(parts) >= 2 {
				base := parts[0]
				field := parts[1]
				if (g.inMapBody && base == g.currentItemVar) || 
					(g.objectParams != nil && g.objectParams[base]) {
					return fmt.Sprintf("!mi.Truthy(%s[%q])", base, field)
				}
			}
		}
	}

	// For complex conditions, return false with a TODO comment
	// This makes the code compile while indicating what needs fixing
	cleanCond := strings.ReplaceAll(cond, "\"", "'")
	cleanCond = strings.ReplaceAll(cleanCond, "\n", " ")
	return fmt.Sprintf("false /* TODO: %s */", cleanCond)
}

// Helper methods

func (g *Generator) write(s string) {
	g.output.WriteString(s)
}

func (g *Generator) writeln(s string) {
	g.output.WriteString(s)
	g.output.WriteString("\n")
}

func (g *Generator) writef(format string, args ...interface{}) {
	g.output.WriteString(fmt.Sprintf(format, args...))
}

func (g *Generator) writeIndent() {
	for i := 0; i < g.indent; i++ {
		g.output.WriteString("\t")
	}
}

// Utility functions

func tagToMethod(tag string) string {
	// Handle common HTML tags
	methods := map[string]string{
		"a":          "A",
		"abbr":       "Abbr",
		"address":    "Address",
		"article":    "Article",
		"aside":      "Aside",
		"audio":      "Audio",
		"b":          "B",
		"blockquote": "Blockquote",
		"body":       "Body",
		"br":         "Br",
		"button":     "Button",
		"canvas":     "Canvas",
		"caption":    "Caption",
		"code":       "Code",
		"col":        "Col",
		"colgroup":   "Colgroup",
		"div":        "Div",
		"dl":         "Dl",
		"dt":         "Dt",
		"dd":         "Dd",
		"em":         "Em",
		"fieldset":   "Fieldset",
		"figcaption": "Figcaption",
		"figure":     "Figure",
		"footer":     "Footer",
		"form":       "Form",
		"h1":         "H1",
		"h2":         "H2",
		"h3":         "H3",
		"h4":         "H4",
		"h5":         "H5",
		"h6":         "H6",
		"head":       "Head",
		"header":     "Header",
		"hr":         "Hr",
		"html":       "Html",
		"i":          "I",
		"iframe":     "Iframe",
		"img":        "Img",
		"input":      "Input",
		"label":      "Label",
		"legend":     "Legend",
		"li":         "Li",
		"link":       "Link",
		"main":       "Main",
		"meta":       "Meta",
		"nav":        "Nav",
		"noscript":   "Noscript",
		"ol":         "Ol",
		"optgroup":   "Optgroup",
		"option":     "Option",
		"p":          "P",
		"picture":    "Picture",
		"pre":        "Pre",
		"progress":   "Progress",
		"script":     "Script",
		"section":    "Section",
		"select":     "Select",
		"small":      "Small",
		"source":     "Source",
		"span":       "Span",
		"strong":     "Strong",
		"style":      "Style",
		"sub":        "Sub",
		"summary":    "Summary",
		"sup":        "Sup",
		"table":      "Table",
		"tbody":      "Tbody",
		"td":         "Td",
		"template":   "Template",
		"textarea":   "Textarea",
		"tfoot":      "Tfoot",
		"th":         "Th",
		"thead":      "Thead",
		"time":       "Time",
		"title":      "Title",
		"tr":         "Tr",
		"track":      "Track",
		"u":          "U",
		"ul":         "Ul",
		"video":      "Video",
		"wbr":        "Wbr",
	}

	if method, ok := methods[strings.ToLower(tag)]; ok {
		return method
	}

	// Unknown tag - use El() helper
	return fmt.Sprintf("El(%q)", tag)
}

func attrToMinty(attr string) string {
	attrs := map[string]string{
		"class":       "mi.Class",
		"className":   "mi.Class",
		"id":          "mi.ID",
		"href":        "mi.Href",
		"src":         "mi.Src",
		"alt":         "mi.Alt",
		"title":       "mi.Title",
		"type":        "mi.Type",
		"name":        "mi.Name",
		"value":       "mi.Value",
		"placeholder": "mi.Placeholder",
		"disabled":    "mi.Disabled",
		"checked":     "mi.Checked",
		"selected":    "mi.Selected",
		"required":    "mi.Required",
		"readonly":    "mi.Readonly",
		"multiple":    "mi.Multiple",
		"autofocus":   "mi.Autofocus",
		"autoplay":    "mi.Autoplay",
		"controls":    "mi.Controls",
		"loop":        "mi.Loop",
		"muted":       "mi.Muted",
		"for":         "mi.For",
		"htmlFor":     "mi.For",
		"action":      "mi.Action",
		"method":      "mi.Method",
		"target":      "mi.Target",
		"rel":         "mi.Rel",
		"role":        "mi.Role",
		"tabindex":    "mi.TabIndex",
		"tabIndex":    "mi.TabIndex",
		"style":       "mi.Style",
		"width":       "mi.Width",
		"height":      "mi.Height",
		"min":         "mi.Min",
		"max":         "mi.Max",
		"step":        "mi.Step",
		"pattern":     "mi.Pattern",
		"maxlength":   "mi.MaxLength",
		"maxLength":   "mi.MaxLength",
		"minlength":   "mi.MinLength",
		"minLength":   "mi.MinLength",
		"cols":        "mi.Cols",
		"rows":        "mi.Rows",
		"colspan":     "mi.Colspan",
		"colSpan":     "mi.Colspan",
		"rowspan":     "mi.Rowspan",
		"rowSpan":     "mi.Rowspan",
		"scope":       "mi.Scope",
		"headers":     "mi.Headers",
		"accept":      "mi.Accept",
		"enctype":     "mi.Enctype",
		"novalidate":  "mi.Novalidate",
		"noValidate":  "mi.Novalidate",
		"async":       "mi.Async",
		"defer":       "mi.Defer",
		"crossorigin": "mi.Crossorigin",
		"integrity":   "mi.Integrity",
		"loading":     "mi.Loading",
		"decoding":    "mi.Decoding",
		"srcset":      "mi.Srcset",
		"sizes":       "mi.Sizes",
		"media":       "mi.Media",
		"download":    "mi.Download",
		"hreflang":    "mi.Hreflang",
		"ping":        "mi.Ping",
		"referrerpolicy": "mi.Referrerpolicy",
		"sandbox":     "mi.Sandbox",
		"allow":       "mi.Allow",
		"allowfullscreen": "mi.Allowfullscreen",
		"frameborder": "mi.Attr(\"frameborder\"",
		"lang":        "mi.Lang",
		"translate":   "mi.Translate",
		"dir":         "mi.Dir",
		"hidden":      "mi.Hidden",
		"draggable":   "mi.Draggable",
		"spellcheck":  "mi.Spellcheck",
		"contenteditable": "mi.Contenteditable",
		// HTMX attributes
		"hx-get":       "mi.HtmxGet",
		"hx-post":      "mi.HtmxPost",
		"hx-put":       "mi.HtmxPut",
		"hx-delete":    "mi.HtmxDelete",
		"hx-patch":     "mi.HtmxPatch",
		"hx-target":    "mi.HtmxTarget",
		"hx-swap":      "mi.HtmxSwap",
		"hx-trigger":   "mi.HtmxTrigger",
		"hx-indicator": "mi.HtmxIndicator",
		"hx-push-url":  "mi.HtmxPushURL",
		"hx-select":    "mi.HtmxSelect",
		"hx-confirm":   "mi.HtmxConfirm",
		"hx-boost":     "mi.HtmxBoost",
	}

	if minty, ok := attrs[attr]; ok {
		return minty
	}

	// Data attributes - handled separately in generateAttribute
	if strings.HasPrefix(attr, "data-") {
		return ""
	}

	// Aria attributes - not in minty, will use mi.Attr
	if strings.HasPrefix(attr, "aria-") {
		return ""
	}

	return ""
}

func isComponentRef(tag string) bool {
	if len(tag) == 0 {
		return false
	}
	// PascalCase = first letter uppercase
	return tag[0] >= 'A' && tag[0] <= 'Z'
}

// isComponentName checks if a tag name is a React component (starts with uppercase)
func isComponentName(tag string) bool {
	if len(tag) == 0 {
		return false
	}
	return tag[0] >= 'A' && tag[0] <= 'Z'
}

func isSimpleIdent(s string) bool {
	if len(s) == 0 {
		return false
	}
	for i, ch := range s {
		if i == 0 {
			if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_') {
				return false
			}
		} else {
			if !((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_') {
				return false
			}
		}
	}
	return true
}

func toCamelCase(s string) string {
	// Convert kebab-case to camelCase
	parts := strings.Split(s, "-")
	for i := 1; i < len(parts); i++ {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(string(parts[i][0])) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}
